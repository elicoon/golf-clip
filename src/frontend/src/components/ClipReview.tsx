import { useState, useRef, useEffect, useCallback } from 'react'
import { useAppStore } from '../stores/appStore'
import { Scrubber } from './Scrubber'
import { TrajectoryEditor } from './TrajectoryEditor'
import { PointStatusTracker, ReviewStep } from './PointStatusTracker'
import { TracerConfigPanel, TracerConfig } from './TracerConfigPanel'

interface ClipReviewProps {
  jobId: string
  videoPath: string
  onComplete: (exportedClips: string[]) => void
}

type LoadingState = 'idle' | 'loading' | 'error'

interface TrajectoryPoint {
  timestamp: number
  x: number
  y: number
  confidence: number
  interpolated: boolean
}

interface TrajectoryData {
  shot_id: number
  points: TrajectoryPoint[]
  confidence: number
  apex_point?: TrajectoryPoint
  frame_width: number
  frame_height: number
  is_manual_override: boolean
}

interface ExportProgress {
  export_job_id: string
  status: string
  total_clips: number
  exported_count: number
  current_clip: number | null
  progress: number
  output_dir: string
  exported: string[]
  errors: { shot_id: number; error: string }[]
  has_errors: boolean
}

export function ClipReview({ jobId, videoPath, onComplete }: ClipReviewProps) {
  const { shots, updateShot } = useAppStore()
  const [currentShotIndex, setCurrentShotIndex] = useState(0)
  const [isPlaying, setIsPlaying] = useState(false)
  const [loadingState, setLoadingState] = useState<LoadingState>('idle')
  const [errorMessage, setErrorMessage] = useState<string | null>(null)
  const [videoLoaded, setVideoLoaded] = useState(false)
  const [exportProgress, setExportProgress] = useState<ExportProgress | null>(null)
  const [showExportModal, setShowExportModal] = useState(false)
  const [showTracer, setShowTracer] = useState(true)
  const [trajectory, setTrajectory] = useState<TrajectoryData | null>(null)
  const [trajectoryLoading, setTrajectoryLoading] = useState(false)
  const [exportWithTracer, setExportWithTracer] = useState(true)
  const [currentTime, setCurrentTime] = useState(0)

  // Auto-loop state
  const [autoLoopEnabled, setAutoLoopEnabled] = useState(true)
  const loopPauseTimeoutRef = useRef<number | null>(null)

  // Landing point marking state
  const [landingPoint, setLandingPoint] = useState<{x: number, y: number} | null>(null)
  const [trajectoryProgress, setTrajectoryProgress] = useState<number | null>(null)
  const [trajectoryMessage, setTrajectoryMessage] = useState<string>('')
  const [detectionWarnings, setDetectionWarnings] = useState<string[]>([])
  const [trajectoryError, setTrajectoryError] = useState<string | null>(null)

  // Debug: early detection stats for debug counter display
  const [earlyDetectionStats, setEarlyDetectionStats] = useState<{frames_analyzed: number, frames_with_ball: number} | null>(null)

  // Tracer configuration panel state
  const [showConfigPanel, setShowConfigPanel] = useState(false)
  const [tracerConfig, setTracerConfig] = useState<TracerConfig>({
    height: 'medium',
    shape: 'straight',
    startingLine: 'center',
    flightTime: 3.0,
  })
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)
  const [isMarkingApex, setIsMarkingApex] = useState(false)
  const [apexPoint, setApexPoint] = useState<{x: number, y: number} | null>(null)
  const [isMarkingOrigin, setIsMarkingOrigin] = useState(false)
  const [originPoint, setOriginPoint] = useState<{x: number, y: number} | null>(null)

  // Track which config options user has tried (for "doesn't look right" feedback)
  const [triedInputs, setTriedInputs] = useState<Set<string>>(new Set())
  // Track how many times user clicked "still doesn't look right" (for showing fallback actions)
  const [feedbackClickCount, setFeedbackClickCount] = useState(0)

  // Track auto-generated parameters for ML feedback
  const [autoGeneratedParams, setAutoGeneratedParams] = useState<TracerConfig | null>(null)
  // Track whether user has configured and regenerated the tracer
  const [hasConfiguredTracer, setHasConfiguredTracer] = useState(false)

  // Review step state machine:
  // - marking_landing: "Click where the ball landed" (initial state - direct click to mark)
  // - generating: Auto-generating tracer (loading state)
  // - reviewing: "Does this tracer look right?"
  const [reviewStep, setReviewStep] = useState<ReviewStep>('marking_landing')

  // Default trajectory configuration (used to reset config state)
  const DEFAULT_CONFIG: TracerConfig = {
    height: 'medium',
    shape: 'straight',
    startingLine: 'center',
    flightTime: 3.0,
  }

  // Zoom state
  const [zoomLevel, setZoomLevel] = useState(1)
  const [panOffset, setPanOffset] = useState({ x: 0, y: 0 })
  const [isPanning, setIsPanning] = useState(false)
  const panStartRef = useRef({ x: 0, y: 0, offsetX: 0, offsetY: 0 })

  const videoRef = useRef<HTMLVideoElement>(null)
  const eventSourceRef = useRef<EventSource | null>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  // Track generation ID to prevent stale EventSource callbacks from updating state
  const generationIdRef = useRef(0)
  // Track if component is mounted to prevent setState on unmounted component
  const isMountedRef = useRef(true)
  // Handler refs to avoid stale closures in keyboard event handler
  const handleAcceptRef = useRef<() => void>(() => {})
  const handleRejectRef = useRef<() => void>(() => {})
  // State refs to avoid stale closures in keyboard handler conditions
  const reviewStepRef = useRef<ReviewStep>('marking_landing')
  const trajectoryRef = useRef<TrajectoryData | null>(null)

  // Filter to shots needing review (confidence < 70%)
  const shotsNeedingReview = shots.filter((s) => s.confidence < 0.7)
  const currentShot = shotsNeedingReview[currentShotIndex]

  // Seek to clip start when shot changes
  useEffect(() => {
    if (videoRef.current && currentShot) {
      videoRef.current.currentTime = currentShot.clip_start
    }
  }, [currentShot])

  // Fetch trajectory when shot changes
  useEffect(() => {
    if (currentShot) {
      setTrajectoryLoading(true)
      fetch(`http://127.0.0.1:8420/api/trajectory/${jobId}/${currentShot.id}`)
        .then(res => res.ok ? res.json() : null)
        .then(data => setTrajectory(data))
        .catch(() => setTrajectory(null))
        .finally(() => setTrajectoryLoading(false))
    } else {
      setTrajectory(null)
    }
  }, [currentShot?.id, jobId])

  // Reset marking state when shot changes
  useEffect(() => {
    setLandingPoint(null)
    setReviewStep('marking_landing')
    setTrajectoryProgress(null)
    setTrajectoryMessage('')
    setDetectionWarnings([])
    setTrajectoryError(null)
    // Reset zoom when shot changes
    setZoomLevel(1)
    setPanOffset({ x: 0, y: 0 })
    // Reset config panel state
    setShowConfigPanel(false)
    setTracerConfig(DEFAULT_CONFIG)
    setHasUnsavedChanges(false)
    setIsMarkingApex(false)
    setApexPoint(null)
    setIsMarkingOrigin(false)
    setOriginPoint(null)
    // Reset feedback tracking state
    setTriedInputs(new Set())
    setFeedbackClickCount(0)
    // Reset tracer feedback tracking state
    setAutoGeneratedParams(null)
    setHasConfiguredTracer(false)
  }, [currentShot?.id])

  // Cleanup EventSource on unmount and track mounted state
  useEffect(() => {
    isMountedRef.current = true
    return () => {
      isMountedRef.current = false
      if (eventSourceRef.current) {
        eventSourceRef.current.close()
      }
    }
  }, [])

  // Track current video time for trajectory rendering and enforce clip boundaries with auto-loop
  useEffect(() => {
    const video = videoRef.current
    if (!video || !currentShot) return

    const handleTimeUpdate = () => {
      setCurrentTime(video.currentTime)

      // When reaching clip end, pause briefly then restart (auto-loop)
      if (video.currentTime >= currentShot.clip_end && !video.paused) {
        video.pause()
        setIsPlaying(false)

        if (autoLoopEnabled) {
          // Clear any existing timeout
          if (loopPauseTimeoutRef.current) {
            clearTimeout(loopPauseTimeoutRef.current)
          }

          // Pause for 750ms, then restart from clip start
          loopPauseTimeoutRef.current = window.setTimeout(() => {
            if (videoRef.current && autoLoopEnabled) {
              videoRef.current.currentTime = currentShot.clip_start
              videoRef.current.play().catch(() => {
                // Autoplay may be blocked, ignore
              })
              setIsPlaying(true)
            }
          }, 750)
        }
      }
    }

    video.addEventListener('timeupdate', handleTimeUpdate)
    return () => {
      video.removeEventListener('timeupdate', handleTimeUpdate)
      // Cleanup timeout on unmount
      if (loopPauseTimeoutRef.current) {
        clearTimeout(loopPauseTimeoutRef.current)
      }
    }
  }, [currentShot, autoLoopEnabled])

  // Auto-play clip when video is loaded and shot changes
  useEffect(() => {
    const video = videoRef.current
    if (!video || !videoLoaded || !currentShot || !autoLoopEnabled) return

    // Small delay to ensure video is ready
    const startAutoPlay = setTimeout(() => {
      if (videoRef.current && autoLoopEnabled) {
        videoRef.current.currentTime = currentShot.clip_start
        videoRef.current.play().catch(() => {
          // Autoplay may be blocked by browser policy, ignore
        })
        setIsPlaying(true)
      }
    }, 100)

    return () => clearTimeout(startAutoPlay)
  }, [videoLoaded, currentShot?.id, autoLoopEnabled])

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Ignore if user is typing in an input
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return
      }

      switch (e.key) {
        case ' ':
          e.preventDefault()
          togglePlayPause()
          break
        case 'ArrowLeft':
          e.preventDefault()
          if (e.shiftKey) {
            // Jump 1 second back
            stepTime(-1)
          } else {
            // Step one frame back
            stepFrame(-1)
          }
          break
        case 'ArrowRight':
          e.preventDefault()
          if (e.shiftKey) {
            // Jump 1 second forward
            stepTime(1)
          } else {
            // Step one frame forward
            stepFrame(1)
          }
          break
        case 'ArrowUp':
          e.preventDefault()
          // Go to previous shot
          if (currentShotIndex > 0) {
            setCurrentShotIndex(currentShotIndex - 1)
          }
          break
        case 'ArrowDown':
          e.preventDefault()
          // Go to next shot
          if (currentShotIndex < shotsNeedingReview.length - 1) {
            setCurrentShotIndex(currentShotIndex + 1)
          }
          break
        case 'Enter':
          e.preventDefault()
          if (reviewStepRef.current === 'reviewing' && trajectoryRef.current) {
            handleAcceptRef.current()
          }
          break
        case 'Escape':
        case 'Backspace':
          e.preventDefault()
          handleRejectRef.current()
          break
        case '[':
          // Set start to current time
          if (videoRef.current && currentShot) {
            const newStart = Math.max(0, videoRef.current.currentTime)
            if (newStart < currentShot.clip_end - 0.5) {
              handleTimeUpdate(newStart, currentShot.clip_end)
            }
          }
          break
        case ']':
          // Set end to current time
          if (videoRef.current && currentShot) {
            const newEnd = videoRef.current.currentTime
            if (newEnd > currentShot.clip_start + 0.5) {
              handleTimeUpdate(currentShot.clip_start, newEnd)
            }
          }
          break
        case '+':
        case '=':
          e.preventDefault()
          handleZoomIn()
          break
        case '-':
        case '_':
          e.preventDefault()
          handleZoomOut()
          break
        case '0':
          e.preventDefault()
          handleZoomReset()
          break
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  // Handlers use refs to avoid stale closures; only re-subscribe on shot navigation changes
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentShotIndex, shotsNeedingReview.length])

  const handleTimeUpdate = useCallback((newStart: number, newEnd: number) => {
    if (currentShot) {
      updateShot(currentShot.id, {
        clip_start: newStart,
        clip_end: newEnd,
      })
    }
  }, [currentShot, updateShot])

  // Submit true positive feedback when user proceeds with the shot
  const submitTruePositiveFeedback = async () => {
    if (!currentShot) return

    try {
      await fetch(`http://127.0.0.1:8420/api/feedback/${jobId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          feedback: [{
            shot_id: currentShot.id,
            feedback_type: 'true_positive',
          }]
        }),
      })
    } catch (error) {
      // Don't block the UI on feedback errors - just log
      console.error('Failed to submit feedback:', error)
    }
  }

  // Submit tracer feedback for ML training
  const submitTracerFeedback = useCallback(async (
    feedbackType: 'tracer_auto_accepted' | 'tracer_configured' | 'tracer_reluctant_accept' | 'tracer_skip' | 'tracer_rejected',
    finalParams: TracerConfig | null = null
  ) => {
    if (!currentShot || !landingPoint) return

    // Get origin point from trajectory's first point (where ball starts)
    // Fallback to default position if trajectory not available
    const originPoint = trajectory?.points?.[0]
      ? { x: trajectory.points[0].x, y: trajectory.points[0].y }
      : { x: 0.5, y: 0.8 }

    const payload = {
      shot_id: currentShot.id,
      feedback_type: feedbackType,
      auto_params: autoGeneratedParams ? {
        height: autoGeneratedParams.height,
        shape: autoGeneratedParams.shape,
        starting_line: autoGeneratedParams.startingLine,
        flight_time: autoGeneratedParams.flightTime,
      } : null,
      final_params: finalParams ? {
        height: finalParams.height,
        shape: finalParams.shape,
        starting_line: finalParams.startingLine,
        flight_time: finalParams.flightTime,
      } : null,
      origin_point: originPoint,
      landing_point: landingPoint,
      apex_point: apexPoint,
    }

    try {
      await fetch(`http://127.0.0.1:8420/api/tracer-feedback/${jobId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      })
    } catch (error) {
      // Don't block the UI on feedback errors - just log
      console.error('Failed to submit tracer feedback:', error)
    }
  }, [currentShot, landingPoint, trajectory, autoGeneratedParams, apexPoint, jobId])

  const handleAccept = async () => {
    if (!currentShot || loadingState === 'loading') return

    setLoadingState('loading')
    setErrorMessage(null)

    // Submit true positive feedback (fire-and-forget)
    submitTruePositiveFeedback()

    // Submit tracer feedback for ML training (fire-and-forget)
    if (trajectory && landingPoint) {
      if (hasConfiguredTracer) {
        // User configured the tracer and then accepted
        submitTracerFeedback('tracer_configured', tracerConfig)
      } else {
        // User accepted the auto-generated tracer without changes
        submitTracerFeedback('tracer_auto_accepted', null)
      }
    }

    try {
      // Mark as approved (confidence = 1.0)
      updateShot(currentShot.id, { confidence: 1.0 })

      // Send update to server
      const response = await fetch(`http://127.0.0.1:8420/api/shots/${jobId}/update`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify([
          {
            shot_id: currentShot.id,
            start_time: currentShot.clip_start,
            end_time: currentShot.clip_end,
            approved: true,
          },
        ]),
      })

      if (!response.ok) {
        throw new Error('Failed to save shot')
      }

      setLoadingState('idle')

      // Check if this was the last shot needing review
      if (shotsNeedingReview.length === 1) {
        // All shots reviewed, export clips
        // handleExportComplete() will call onComplete() when user clicks Done
        await exportClips()
      } else {
        // Reset to index 0 - the accepted shot will be filtered out on re-render,
        // so remaining shots shift down. Setting to 0 ensures we don't go out of bounds
        // if user had navigated to a later shot.
        setCurrentShotIndex(0)
      }
    } catch (error) {
      setLoadingState('error')
      setErrorMessage(error instanceof Error ? error.message : 'Failed to save shot')
    }
  }

  const handleReject = async () => {
    if (!currentShot || loadingState === 'loading') return

    // Submit false positive feedback
    try {
      await fetch(`http://127.0.0.1:8420/api/feedback/${jobId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          feedback: [{
            shot_id: currentShot.id,
            feedback_type: 'false_positive',
          }]
        }),
      })
    } catch (error) {
      // Don't block the UI on feedback errors - just log
      console.error('Failed to submit feedback:', error)
    }

    // Skip this shot (don't include in export)
    updateShot(currentShot.id, { confidence: 0 })

    if (currentShotIndex < shotsNeedingReview.length - 1) {
      setCurrentShotIndex(currentShotIndex + 1)
    } else {
      // handleExportComplete() will call onComplete() when user clicks Done
      await exportClips()
    }
  }

  // Keep handler and state refs updated to avoid stale closures in keyboard handler
  useEffect(() => {
    handleAcceptRef.current = handleAccept
    handleRejectRef.current = handleReject
    reviewStepRef.current = reviewStep
    trajectoryRef.current = trajectory
  })

  const exportClips = async () => {
    setLoadingState('loading')
    setErrorMessage(null)
    setShowExportModal(true)

    try {
      // Get fresh state from store (shots variable may be stale from render cycle)
      const currentShots = useAppStore.getState().shots
      const approvedClips = currentShots
        .filter((s) => s.confidence >= 0.7)
        .map((s) => ({
          shot_id: s.id,
          start_time: s.clip_start,
          end_time: s.clip_end,
          approved: true,
        }))

      const outputDir = videoPath.replace(/\.[^.]+$/, '_clips')

      // Start export job
      const response = await fetch('http://127.0.0.1:8420/api/export', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          job_id: jobId,
          clips: approvedClips,
          output_dir: outputDir,
          filename_pattern: 'shot_{shot_id}',
          render_tracer: exportWithTracer,
          tracer_style: exportWithTracer ? { color: '#FFFFFF', glow_enabled: true } : undefined,
        }),
      })

      if (!response.ok) {
        throw new Error('Failed to start export')
      }

      const { export_job_id, total_clips } = await response.json()

      // Initialize export progress
      setExportProgress({
        export_job_id,
        status: 'pending',
        total_clips,
        exported_count: 0,
        current_clip: null,
        progress: 0,
        output_dir: outputDir,
        exported: [],
        errors: [],
        has_errors: false,
      })

      // Poll for progress
      await pollExportProgress(export_job_id)

    } catch (error) {
      setLoadingState('error')
      setShowExportModal(false)
      setErrorMessage(error instanceof Error ? error.message : 'Failed to export clips')
    }
  }

  const pollExportProgress = async (exportJobId: string) => {
    const pollInterval = 500 // 500ms
    const maxAttempts = 600 // 5 minutes max

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const response = await fetch(`http://127.0.0.1:8420/api/export/${exportJobId}/status`)

        if (!response.ok) {
          throw new Error('Failed to get export status')
        }

        const status: ExportProgress = await response.json()
        setExportProgress(status)

        if (status.status === 'complete' || status.status === 'error') {
          setLoadingState('idle')
          // Keep modal open to show results
          return
        }

        await new Promise((resolve) => setTimeout(resolve, pollInterval))
      } catch (error) {
        console.error('Error polling export status:', error)
        setLoadingState('error')
        setErrorMessage('Lost connection while exporting')
        return
      }
    }

    // Timeout
    setLoadingState('error')
    setErrorMessage('Export timed out')
  }

  const handleExportComplete = () => {
    const exported = exportProgress?.exported || []
    setShowExportModal(false)
    setExportProgress(null)
    onComplete(exported)
  }

  const togglePlayPause = useCallback(() => {
    if (videoRef.current && currentShot) {
      if (isPlaying) {
        videoRef.current.pause()
      } else {
        // If at or past clip end, restart from clip start
        if (videoRef.current.currentTime >= currentShot.clip_end - 0.05) {
          videoRef.current.currentTime = currentShot.clip_start
        }
        videoRef.current.play()
      }
      setIsPlaying(!isPlaying)
    }
  }, [isPlaying, currentShot])

  const stepFrame = useCallback((direction: number) => {
    if (videoRef.current) {
      // Assuming 60fps (1/60 â‰ˆ 0.0167 seconds per frame)
      videoRef.current.currentTime += direction * (1 / 60)
    }
  }, [])

  const stepTime = useCallback((seconds: number) => {
    if (videoRef.current) {
      videoRef.current.currentTime += seconds
    }
  }, [])

  // Zoom handlers
  const ZOOM_MIN = 1
  const ZOOM_MAX = 4
  const ZOOM_STEP = 0.5

  const handleZoomIn = useCallback(() => {
    setZoomLevel(prev => Math.min(ZOOM_MAX, prev + ZOOM_STEP))
  }, [])

  const handleZoomOut = useCallback(() => {
    setZoomLevel(prev => {
      const newZoom = Math.max(ZOOM_MIN, prev - ZOOM_STEP)
      // Reset pan when zooming back to 1x
      if (newZoom === 1) {
        setPanOffset({ x: 0, y: 0 })
      }
      return newZoom
    })
  }, [])

  const handleZoomReset = useCallback(() => {
    setZoomLevel(1)
    setPanOffset({ x: 0, y: 0 })
  }, [])

  // Pan handlers for zoomed view
  const handlePanStart = useCallback((e: React.MouseEvent) => {
    if (zoomLevel <= 1) return
    setIsPanning(true)
    panStartRef.current = {
      x: e.clientX,
      y: e.clientY,
      offsetX: panOffset.x,
      offsetY: panOffset.y,
    }
  }, [zoomLevel, panOffset])

  const handlePanMove = useCallback((e: React.MouseEvent) => {
    if (!isPanning || zoomLevel <= 1) return
    const dx = e.clientX - panStartRef.current.x
    const dy = e.clientY - panStartRef.current.y
    // Limit pan to prevent going too far off-screen
    const maxPan = (zoomLevel - 1) * 50 // % of container
    setPanOffset({
      x: Math.max(-maxPan, Math.min(maxPan, panStartRef.current.offsetX + (dx / 5))),
      y: Math.max(-maxPan, Math.min(maxPan, panStartRef.current.offsetY + (dy / 5))),
    })
  }, [isPanning, zoomLevel])

  const handlePanEnd = useCallback(() => {
    setIsPanning(false)
  }, [])

  // Generate trajectory with current configuration
  const generateTrajectory = useCallback(() => {
    if (!currentShot || !landingPoint) return

    // Increment generation ID to invalidate any stale callbacks
    const currentGenId = ++generationIdRef.current

    // Cancel previous connection if any
    if (eventSourceRef.current) {
      eventSourceRef.current.close()
    }

    setReviewStep('generating')
    setTrajectoryProgress(0)
    setTrajectoryMessage('Starting...')
    setDetectionWarnings([])
    setTrajectoryError(null)
    setEarlyDetectionStats(null)
    setHasUnsavedChanges(false)

    const params = new URLSearchParams({
      starting_line: tracerConfig.startingLine,
      shot_shape: tracerConfig.shape,
      shot_height: tracerConfig.height,
      flight_time: tracerConfig.flightTime.toString(),
      landing_x: landingPoint.x.toString(),
      landing_y: landingPoint.y.toString(),
    })

    // Add apex point if marked
    if (apexPoint) {
      params.set('apex_x', apexPoint.x.toString())
      params.set('apex_y', apexPoint.y.toString())
    }

    // Add manual origin point if marked (overrides auto-detection)
    if (originPoint) {
      params.set('origin_x', originPoint.x.toString())
      params.set('origin_y', originPoint.y.toString())
    }

    const url = `http://127.0.0.1:8420/api/trajectory/${jobId}/${currentShot.id}/generate?${params}`
    const eventSource = new EventSource(url)
    eventSourceRef.current = eventSource

    eventSource.addEventListener('progress', (e) => {
      // Ignore stale callbacks from previous generations or unmounted component
      if (generationIdRef.current !== currentGenId || !isMountedRef.current) return
      const data = JSON.parse(e.data)
      setTrajectoryProgress(data.progress)
      setTrajectoryMessage(data.message || '')
    })

    eventSource.addEventListener('warning', (e) => {
      // Ignore stale callbacks from previous generations or unmounted component
      if (generationIdRef.current !== currentGenId || !isMountedRef.current) return
      const data = JSON.parse(e.data)
      setDetectionWarnings(prev => [...prev, data.message])
    })

    eventSource.addEventListener('complete', (e) => {
      // Ignore stale callbacks from previous generations or unmounted component
      if (generationIdRef.current !== currentGenId || !isMountedRef.current) {
        eventSource.close()
        return
      }
      const data = JSON.parse(e.data)
      setTrajectory(data.trajectory)
      setTrajectoryProgress(null)
      setTrajectoryMessage('')
      setReviewStep('reviewing')
      // Capture early detection stats for debug display
      if (data.early_detection_stats) {
        setEarlyDetectionStats(data.early_detection_stats)
      }

      // Store auto-generated params only on first generation (not after user config)
      if (!hasConfiguredTracer) {
        setAutoGeneratedParams({
          height: tracerConfig.height,
          shape: tracerConfig.shape,
          startingLine: tracerConfig.startingLine,
          flightTime: tracerConfig.flightTime,
        })
      }

      eventSource.close()
      eventSourceRef.current = null

      // Autoplay: seek to clip start and play
      if (videoRef.current && currentShot) {
        videoRef.current.currentTime = currentShot.clip_start
        videoRef.current.play().catch(() => {
          // Autoplay may be blocked by browser policy, ignore error
        })
      }
    })

    eventSource.addEventListener('error', (e) => {
      // Ignore stale callbacks from previous generations or unmounted component
      if (generationIdRef.current !== currentGenId || !isMountedRef.current) {
        eventSource.close()
        return
      }
      try {
        const data = JSON.parse((e as MessageEvent).data)
        setTrajectoryError(data.error || 'Failed to generate trajectory')
      } catch {
        setTrajectoryError('Connection lost during trajectory generation')
      }
      setTrajectoryProgress(null)
      setReviewStep('marking_landing')
      eventSource.close()
      eventSourceRef.current = null
    })

    eventSource.onerror = () => {
      // Ignore stale callbacks from previous generations or unmounted component
      if (generationIdRef.current !== currentGenId || !isMountedRef.current) {
        eventSource.close()
        return
      }
      setTrajectoryError('Connection lost during trajectory generation')
      setTrajectoryProgress(null)
      setReviewStep('marking_landing')
      eventSource.close()
      eventSourceRef.current = null
    }
  }, [jobId, currentShot?.id, landingPoint, tracerConfig, apexPoint, originPoint])

  // Auto-trigger trajectory generation when landing is marked
  useEffect(() => {
    if (landingPoint && reviewStep === 'marking_landing') {
      // Small delay to show the landing marker before generating
      const timeout = setTimeout(() => {
        generateTrajectory()
      }, 200)
      return () => clearTimeout(timeout)
    }
  }, [landingPoint, reviewStep, generateTrajectory])

  const handleCanvasClick = useCallback((x: number, y: number) => {
    if (loadingState === 'loading' || reviewStep === 'generating') return

    // Handle origin marking mode (from config panel)
    if (isMarkingOrigin) {
      setOriginPoint({ x, y })
      setIsMarkingOrigin(false)
      setHasUnsavedChanges(true)
      // Track that user has tried marking origin
      setTriedInputs(prev => new Set([...prev, 'origin']))
      return
    }

    // Handle apex marking mode (from config panel)
    if (isMarkingApex) {
      setApexPoint({ x, y })
      setIsMarkingApex(false)
      setHasUnsavedChanges(true)
      // Track that user has tried marking apex
      setTriedInputs(prev => new Set([...prev, 'apex']))
      return
    }

    if (reviewStep === 'marking_landing') {
      setLandingPoint({ x, y })
      // generateTrajectory will be triggered by the useEffect above
    }
  }, [loadingState, reviewStep, isMarkingApex, isMarkingOrigin])

  const clearMarking = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close()
      eventSourceRef.current = null
    }

    setLandingPoint(null)
    setReviewStep('marking_landing')
    setTrajectory(null)
    setTrajectoryProgress(null)
    setTrajectoryMessage('')
    setDetectionWarnings([])
    setTrajectoryError(null)
    setEarlyDetectionStats(null)
    // Reset config panel state
    setShowConfigPanel(false)
    setTracerConfig(DEFAULT_CONFIG)
    setHasUnsavedChanges(false)
    setIsMarkingApex(false)
    setApexPoint(null)
    setIsMarkingOrigin(false)
    setOriginPoint(null)
    // Reset tracer feedback tracking state
    setAutoGeneratedParams(null)
    setHasConfiguredTracer(false)
  }, [])

  // Re-mark landing without resetting all config state
  // Preserves: tracerConfig, triedInputs, showConfigPanel
  // Clears: landingPoint, trajectory, apex, sets step to marking_landing
  const handleRemarkLanding = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close()
      eventSourceRef.current = null
    }

    setLandingPoint(null)
    setReviewStep('marking_landing')
    setTrajectory(null)
    setTrajectoryProgress(null)
    setTrajectoryMessage('')
    setDetectionWarnings([])
    setTrajectoryError(null)
    setEarlyDetectionStats(null)
    // Keep config panel state (tracerConfig, showConfigPanel, triedInputs)
    setHasUnsavedChanges(false)
    setIsMarkingApex(false)
    setIsMarkingOrigin(false)
    // Clear apex since it depends on trajectory shape
    setApexPoint(null)
    // Keep originPoint - user might want to keep their manually marked origin
    // Keep autoGeneratedParams and hasConfiguredTracer for feedback tracking
  }, [])

  const handleVideoLoad = () => {
    setVideoLoaded(true)
  }

  const handleVideoError = () => {
    setVideoLoaded(false)
    setErrorMessage('Failed to load video')
  }

  // Handle step selection from PointStatusTracker
  const handleSelectStep = useCallback((step: ReviewStep) => {
    if (step === 'marking_landing') {
      handleRemarkLanding()
    } else if (step === 'reviewing' && trajectory) {
      setReviewStep('reviewing')
    }
  }, [trajectory, handleRemarkLanding])

  // Handle config changes from TracerConfigPanel - track which inputs user has tried
  const handleConfigChange = useCallback((newConfig: TracerConfig) => {
    // Track which settings have been changed from defaults
    const newTriedInputs = new Set<string>()
    if (newConfig.height !== DEFAULT_CONFIG.height) newTriedInputs.add('height')
    if (newConfig.shape !== DEFAULT_CONFIG.shape) newTriedInputs.add('shape')
    if (newConfig.startingLine !== DEFAULT_CONFIG.startingLine) newTriedInputs.add('startingLine')
    if (Math.abs(newConfig.flightTime - DEFAULT_CONFIG.flightTime) > 0.1) newTriedInputs.add('flightTime')

    // Merge with existing tried inputs
    setTriedInputs(prev => new Set([...prev, ...newTriedInputs]))
    setTracerConfig(newConfig)
    setHasUnsavedChanges(true)
  }, [])

  // Handle mark apex button from config panel
  const handleMarkApex = useCallback(() => {
    setIsMarkingApex(true)
  }, [])

  // Handle mark origin button from config panel
  const handleMarkOrigin = useCallback(() => {
    setIsMarkingOrigin(true)
  }, [])

  // Handle generate from config panel
  const handleConfigGenerate = useCallback(() => {
    // Mark that user has configured the tracer (for feedback tracking)
    setHasConfiguredTracer(true)
    generateTrajectory()
  }, [generateTrajectory])

  // Toggle config panel visibility
  const handleToggleConfigPanel = useCallback(() => {
    setShowConfigPanel(prev => !prev)
  }, [])

  // Calculate which inputs user hasn't tried yet
  const allInputs = ['height', 'shape', 'startingLine', 'flightTime', 'apex', 'origin']
  const missingInputs = allInputs.filter(input => !triedInputs.has(input))
  const hasTriedAllInputs = missingInputs.length === 0

  // Map input keys to friendly names for display
  const friendlyNames: Record<string, string> = {
    height: 'shot height',
    shape: 'shot shape',
    startingLine: 'starting line',
    flightTime: 'flight time',
    apex: 'apex point',
    origin: 'origin point',
  }
  const missingInputsFriendly = missingInputs.map(input => friendlyNames[input] || input)

  // Handle "Tracer still doesn't look right" button click
  const handleTracerFeedback = useCallback(() => {
    // Expand config panel and increment click count
    setShowConfigPanel(true)
    setFeedbackClickCount(prev => prev + 1)
  }, [])

  // Handle accepting shot with current trajectory anyway (reluctant accept)
  const handleAcceptAnyway = useCallback(async () => {
    setFeedbackClickCount(0)

    // Submit tracer_reluctant_accept feedback before accepting
    if (landingPoint) {
      await submitTracerFeedback('tracer_reluctant_accept', tracerConfig)
    }

    handleAccept()
  }, [handleAccept, landingPoint, tracerConfig, submitTracerFeedback])

  // Handle accepting shot without trajectory (rejected tracer)
  const handleAcceptNoTracer = useCallback(async () => {
    setFeedbackClickCount(0)
    if (!currentShot) return

    // Submit tracer_rejected feedback before accepting
    if (landingPoint) {
      await submitTracerFeedback('tracer_rejected', tracerConfig)
    }

    // Clear trajectory and accept
    setTrajectory(null)

    // Delete trajectory from backend
    try {
      await fetch(`http://127.0.0.1:8420/api/trajectory/${jobId}/${currentShot.id}`, {
        method: 'DELETE',
      })
    } catch (error) {
      console.error('Failed to delete trajectory:', error)
    }

    handleAccept()
  }, [currentShot, jobId, handleAccept, landingPoint, tracerConfig, submitTracerFeedback])

  // Handle skipping shot from feedback
  const handleSkipFromFeedback = useCallback(async () => {
    setFeedbackClickCount(0)

    // Submit tracer_skip feedback before rejecting
    if (landingPoint) {
      await submitTracerFeedback('tracer_skip', tracerConfig)
    }

    handleReject()
  }, [handleReject, landingPoint, tracerConfig, submitTracerFeedback])

  // Export progress modal
  const renderExportModal = () => {
    if (!showExportModal || !exportProgress) return null

    const isComplete = exportProgress.status === 'complete'
    const hasErrors = exportProgress.has_errors
    const isExporting = exportProgress.status === 'exporting' || exportProgress.status === 'pending'

    return (
      <div className="export-modal-overlay">
        <div className="export-modal">
          <div className="export-modal-header">
            <h3>{isComplete ? (hasErrors ? 'Export Completed with Errors' : 'Export Complete!') : 'Exporting Clips...'}</h3>
          </div>

          <div className="export-modal-content">
            {isExporting && (
              <>
                <div className="export-progress-bar">
                  <div
                    className="export-progress-fill"
                    style={{ width: `${exportProgress.progress}%` }}
                  />
                </div>
                <p className="export-status">
                  Exporting clip {exportProgress.exported_count + 1} of {exportProgress.total_clips}
                  {exportProgress.current_clip !== null && ` (Shot #${exportProgress.current_clip})`}
                </p>
              </>
            )}

            {isComplete && (
              <>
                <div className="export-success-icon">{hasErrors ? '!' : '>'}</div>
                <p className="export-result">
                  {exportProgress.exported_count} of {exportProgress.total_clips} clips exported successfully
                </p>
                <p className="export-output-dir">
                  Saved to: <code>{exportProgress.output_dir}</code>
                </p>

                {hasErrors && exportProgress.errors.length > 0 && (
                  <div className="export-errors">
                    <p className="export-errors-title">Failed exports:</p>
                    <ul>
                      {exportProgress.errors.map((err, i) => (
                        <li key={i}>
                          {err.shot_id !== null ? `Shot #${err.shot_id}: ` : ''}{err.error}
                        </li>
                      ))}
                    </ul>
                  </div>
                )}

                <button
                  onClick={handleExportComplete}
                  className="btn-primary btn-large"
                >
                  Done
                </button>
              </>
            )}

            {exportProgress.status === 'error' && (
              <>
                <div className="export-error-icon">X</div>
                <p className="export-error-message">Export failed</p>
                {exportProgress.errors.length > 0 && (
                  <p className="export-error-detail">{exportProgress.errors[0]?.error}</p>
                )}
                <button
                  onClick={() => {
                    setShowExportModal(false)
                    setExportProgress(null)
                    setLoadingState('idle')
                  }}
                  className="btn-secondary"
                >
                  Close
                </button>
              </>
            )}
          </div>
        </div>
      </div>
    )
  }

  // All clips reviewed state
  if (!currentShot) {
    return (
      <div className="clip-review clip-review-complete">
        {renderExportModal()}
        <div className="review-complete-icon">{'>'}</div>
        <h2>All clips reviewed!</h2>
        <p className="review-complete-summary">
          {shots.filter((s) => s.confidence >= 0.7).length} clips approved for export
        </p>
        <button
          onClick={exportClips}
          className="btn-primary btn-large"
          disabled={loadingState === 'loading'}
        >
          {loadingState === 'loading' ? (
            <>
              <span className="spinner" />
              Starting Export...
            </>
          ) : (
            'Export Clips'
          )}
        </button>
        {errorMessage && <p className="error-message">{errorMessage}</p>}
      </div>
    )
  }

  const isGenerating = reviewStep === 'generating'

  return (
    <div className="clip-review" ref={containerRef} tabIndex={-1}>
      {renderExportModal()}
      <div className="review-header">
        <h2>
          Review Shot #{currentShot.id}
        </h2>
        <span className="review-progress">
          {currentShotIndex + 1} of {shotsNeedingReview.length}
        </span>
      </div>

      <div className="review-actions">
        <button
          onClick={handleReject}
          className="btn-no-shot"
          disabled={loadingState === 'loading' || isGenerating}
          title="Not a golf shot (Escape)"
        >
          No golf shot
        </button>
        <button
          onClick={handleAccept}
          className="btn-primary btn-next"
          disabled={loadingState === 'loading' || isGenerating || !trajectory}
          title={!trajectory ? "Mark landing point first" : "Next (Enter)"}
        >
          {loadingState === 'loading' ? (
            <>
              <span className="spinner" />
              Saving...
            </>
          ) : (
            'Next'
          )}
        </button>
      </div>

      {/* Instruction banner based on review step */}
      <div className="marking-instruction">
        {reviewStep === 'marking_landing' && (
          <>
            <span className="step-badge">Landing</span>
            <span>Click where the ball landed</span>
            {landingPoint && (
              <button className="btn-reset-inline" onClick={clearMarking} title="Reset and start over">
                Reset
              </button>
            )}
          </>
        )}
        {reviewStep === 'reviewing' && !isMarkingApex && !isMarkingOrigin && (
          <>
            <span className="step-badge complete">Done</span>
            <span>Does this tracer look right?</span>
            <button className="btn-reset-inline" onClick={handleRemarkLanding}>
              Re-mark landing
            </button>
          </>
        )}
        {reviewStep === 'reviewing' && isMarkingApex && (
          <>
            <span className="step-badge">Apex</span>
            <span>Click the highest point of the ball flight</span>
            <button
              className="btn-reset-inline"
              onClick={() => setIsMarkingApex(false)}
            >
              Cancel
            </button>
          </>
        )}
        {reviewStep === 'reviewing' && isMarkingOrigin && (
          <>
            <span className="step-badge">Origin</span>
            <span>Click where the ball starts (address position)</span>
            <button
              className="btn-reset-inline"
              onClick={() => setIsMarkingOrigin(false)}
            >
              Cancel
            </button>
          </>
        )}
      </div>

      <PointStatusTracker
        landingPoint={landingPoint}
        reviewStep={reviewStep}
        isGenerating={isGenerating}
        hasTrajectory={!!trajectory}
        onSelectStep={handleSelectStep}
      />

      {/* Tracer configuration panel - show when reviewing trajectory */}
      {reviewStep === 'reviewing' && trajectory && (
        <>
          <TracerConfigPanel
            config={tracerConfig}
            onChange={handleConfigChange}
            onGenerate={handleConfigGenerate}
            onMarkApex={handleMarkApex}
            onMarkOrigin={handleMarkOrigin}
            hasChanges={hasUnsavedChanges}
            apexMarked={!!apexPoint}
            originMarked={!!originPoint}
            isGenerating={isGenerating}
            isCollapsed={!showConfigPanel}
            onToggleCollapse={handleToggleConfigPanel}
            // Feedback-related props
            feedbackMessage={feedbackClickCount > 0 && !hasTriedAllInputs
              ? `Try adjusting: ${missingInputsFriendly.join(', ')}`
              : undefined}
            triedInputs={feedbackClickCount > 0 ? triedInputs : undefined}
            showFallbackActions={feedbackClickCount > 1 || hasTriedAllInputs}
            onAcceptAnyway={handleAcceptAnyway}
            onSkipShot={handleSkipFromFeedback}
            onAcceptNoTracer={handleAcceptNoTracer}
          />
          {/* "Tracer still doesn't look right" button */}
          <div className="tracer-feedback-trigger">
            <button
              type="button"
              className="btn-tracer-feedback"
              onClick={handleTracerFeedback}
              disabled={isGenerating}
            >
              Tracer still doesn't look right
            </button>
          </div>
        </>
      )}

      {/* Trajectory progress section - only show when generating */}
      {isGenerating && trajectoryProgress !== null && (
        <div className="trajectory-config-above-player">
          <div className="trajectory-progress">
            <div className="progress-header">
              Generating tracer... {trajectoryProgress}%
            </div>
            <div className="progress-bar">
              <div
                className="progress-fill"
                style={{ width: `${trajectoryProgress}%` }}
              />
            </div>
            <div className="progress-message">{trajectoryMessage}</div>
          </div>
        </div>
      )}

      <div className="video-zoom-wrapper">
        {/* Zoom controls */}
        <div className="zoom-controls">
          <button
            className="btn-zoom"
            onClick={handleZoomOut}
            disabled={zoomLevel <= ZOOM_MIN}
            title="Zoom out (-)"
          >
            -
          </button>
          <span className="zoom-level">{zoomLevel}x</span>
          <button
            className="btn-zoom"
            onClick={handleZoomIn}
            disabled={zoomLevel >= ZOOM_MAX}
            title="Zoom in (+)"
          >
            +
          </button>
          {zoomLevel > 1 && (
            <button
              className="btn-zoom btn-zoom-reset"
              onClick={handleZoomReset}
              title="Reset zoom (0)"
            >
              Reset
            </button>
          )}
        </div>

        <div
          className={`video-container ${!videoLoaded ? 'video-loading' : ''} ${zoomLevel > 1 ? 'zoomed' : ''} ${isPanning ? 'panning' : ''}`}
          style={{
            cursor: zoomLevel > 1 && reviewStep !== 'marking_landing'
              ? (isPanning ? 'grabbing' : 'grab')
              : 'default',
          }}
          onMouseDown={handlePanStart}
          onMouseMove={handlePanMove}
          onMouseUp={handlePanEnd}
          onMouseLeave={handlePanEnd}
        >
          {!videoLoaded && (
            <div className="video-loader">
              <div className="spinner-large" />
              <p>Loading video...</p>
            </div>
          )}
          <div
            className="video-zoom-content"
            style={{
              transform: `scale(${zoomLevel}) translate(${panOffset.x}%, ${panOffset.y}%)`,
              transformOrigin: 'center center',
            }}
          >
            <video
              ref={videoRef}
              src={`http://127.0.0.1:8420/api/video?path=${encodeURIComponent(videoPath)}`}
              onPlay={() => setIsPlaying(true)}
              onPause={() => setIsPlaying(false)}
              onLoadedData={handleVideoLoad}
              onError={handleVideoError}
              playsInline
            />
            <TrajectoryEditor
              videoRef={videoRef}
              trajectory={trajectory}
              currentTime={currentTime}
              showTracer={showTracer}
              disabled={isGenerating}
              landingPoint={landingPoint}
              apexPoint={apexPoint}
              originPoint={originPoint}
              onCanvasClick={handleCanvasClick}
              markingStep={reviewStep}
              isMarkingApex={isMarkingApex}
              isMarkingOrigin={isMarkingOrigin}
              onTrajectoryUpdate={(points) => {
                if (!currentShot) return
                fetch(`http://127.0.0.1:8420/api/trajectory/${jobId}/${currentShot.id}`, {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ points }),
                }).catch((err) => console.error('Failed to save trajectory:', err))
              }}
            />
          </div>
        </div>
      </div>

      <Scrubber
        videoRef={videoRef}
        startTime={currentShot.clip_start}
        endTime={currentShot.clip_end}
        onTimeUpdate={handleTimeUpdate}
        disabled={loadingState === 'loading'}
      />

      <div className="playback-controls">
        <button
          onClick={() => stepTime(-1)}
          className="btn-icon"
          title="Back 1 second (Shift + Left)"
          disabled={loadingState === 'loading'}
        >
          {'<<'}
        </button>
        <button
          onClick={() => stepFrame(-1)}
          className="btn-icon"
          title="Previous frame (Left)"
          disabled={loadingState === 'loading'}
        >
          {'<'}
        </button>
        <button
          onClick={togglePlayPause}
          className="btn-primary btn-play"
          title="Play/Pause (Space)"
          disabled={loadingState === 'loading'}
        >
          {isPlaying ? 'Pause' : 'Play'}
        </button>
        <button
          onClick={() => stepFrame(1)}
          className="btn-icon"
          title="Next frame (Right)"
          disabled={loadingState === 'loading'}
        >
          {'>'}
        </button>
        <button
          onClick={() => stepTime(1)}
          className="btn-icon"
          title="Forward 1 second (Shift + Right)"
          disabled={loadingState === 'loading'}
        >
          {'>>'}
        </button>
      </div>

      <div className="tracer-controls">
        <label>
          <input
            type="checkbox"
            checked={autoLoopEnabled}
            onChange={(e) => {
              setAutoLoopEnabled(e.target.checked)
              // Clear any pending loop timeout when disabling
              if (!e.target.checked && loopPauseTimeoutRef.current) {
                clearTimeout(loopPauseTimeoutRef.current)
                loopPauseTimeoutRef.current = null
              }
            }}
          />
          Auto Loop
        </label>
        <label>
          <input
            type="checkbox"
            checked={showTracer}
            onChange={(e) => setShowTracer(e.target.checked)}
            disabled={trajectoryLoading}
          />
          Show Tracer
          {trajectoryLoading && <span className="spinner" style={{ marginLeft: 8 }} />}
        </label>
        <label>
          <input
            type="checkbox"
            checked={exportWithTracer}
            onChange={(e) => setExportWithTracer(e.target.checked)}
          />
          Render Shot Tracers
        </label>
      </div>

      {/* Trajectory errors/warnings */}
      {(trajectoryError || detectionWarnings.length > 0) && (
        <div className="trajectory-config-section">
          {trajectoryError && (
            <div className="trajectory-error">
              <span>! {trajectoryError}</span>
            </div>
          )}
          {detectionWarnings.length > 0 && (
            <div className="detection-warnings">
              {detectionWarnings.map((warning, i) => (
                <div key={i} className="warning-item">
                  <span className="warning-icon">!</span>
                  <span>{warning}</span>
                </div>
              ))}
            </div>
          )}
        </div>
      )}

      <div className="confidence-info">
        <div className="confidence-badge" data-level={getConfidenceLevel(currentShot.confidence)}>
          {Math.round(currentShot.confidence * 100)}%
        </div>
        {currentShot.confidence_reasons.length > 0 && (
          <div className="confidence-reasons">
            {currentShot.confidence_reasons.map((reason, i) => (
              <span key={i} className="reason-tag">{reason}</span>
            ))}
          </div>
        )}
      </div>

      {errorMessage && (
        <div className="error-banner">
          <span className="error-icon">!</span>
          <span>{errorMessage}</span>
          <button onClick={() => setErrorMessage(null)} className="error-dismiss">x</button>
        </div>
      )}

      <div className="time-display">
        <span>Start: {currentShot.clip_start.toFixed(2)}s</span>
        <span className="time-separator">|</span>
        <span>End: {currentShot.clip_end.toFixed(2)}s</span>
        <span className="time-separator">|</span>
        <span>Duration: {(currentShot.clip_end - currentShot.clip_start).toFixed(2)}s</span>
      </div>

      <div className="keyboard-hints">
        <span><kbd>Space</kbd> Play/Pause</span>
        <span><kbd>Left/Right</kbd> Frame step</span>
        <span><kbd>[</kbd><kbd>]</kbd> Set in/out</span>
        <span><kbd>+</kbd><kbd>-</kbd> Zoom</span>
        <span><kbd>Enter</kbd> Next</span>
        <span><kbd>Esc</kbd> Skip</span>
      </div>

      {/* Debug counter for early ball detection */}
      {earlyDetectionStats && (
        <div className="debug-detection-stats">
          <span className="debug-label">Ball Detection Debug:</span>
          <span className="debug-value">
            Frames with ball detected: {earlyDetectionStats.frames_with_ball}/{earlyDetectionStats.frames_analyzed}
            {' '}
            ({Math.round((earlyDetectionStats.frames_with_ball / earlyDetectionStats.frames_analyzed) * 100)}%)
          </span>
        </div>
      )}
    </div>
  )
}

function getConfidenceLevel(confidence: number): 'low' | 'medium' | 'high' {
  if (confidence < 0.4) return 'low'
  if (confidence < 0.7) return 'medium'
  return 'high'
}
